spv <- SpatialPoints(v_acs[,3:4])
# construct spde mesh
v_mesh <- inla.mesh.2d(loc = spv, boundary = region,
max.edge = c(80, 800), cutoff = 40, max.n.strict = 1300L)
# dual mesh for the spde mesh nodes to get the exposure weights
dmesh <- inla.mesh.dual(v_mesh)
nv <- v_mesh$n
domain.polys <- Polygons(list(Polygon(cbind(X,Y))), '0')
domainSP <- SpatialPolygons(list(domain.polys))
# exposure weights
w <- sapply(1:length(dmesh), function(i) {
if (gIntersects(dmesh[i, ], domainSP))
return(gArea(gIntersection(dmesh[i, ], domainSP)))
else return(0)
})
# response vector
y.pp <- rep(0:1, c(nv, nrow(spv@coords)))
# exposure vector
e.pp <- c(w, rep(0, nrow(spv@coords)))
# mesh nodes locations
loc_mesh <- v_mesh$loc[,1:2]
colnames(loc_mesh) <- c('x','y')
imat <- inla.spde.make.A(v_mesh, loc = v_mesh$loc[,1:2])
lmat <- inla.spde.make.A(v_mesh, loc = spv)
# projection matrix for the mesh nodes and the point locations
A.pp <- rbind(imat, lmat)
loc <- rbind(loc_mesh, v_acs[,3:4])
# covariate values at the locations
gal1 <- (loc$x*cos(pi/18) - loc$y*sin(pi/18) - 800)^2 + (loc$x*sin(pi/18) + loc$y*cos(pi/18)-1950)^2/1.733522
gal2 <- ((loc$x-2300)*cos(pi/6)- (loc$y-5800)*sin(pi/6))^2 + ((loc$x-2300)*sin(pi/6) + (loc$y-5800)*cos(pi/6))^2/2.25
gal <- cbind(gal1, gal2)
# spde stuff
nu <- 1
# spde model
spde <- (inla.spde2.pcmatern(mesh = v_mesh, alpha = 2,
prior.range = c(400, 0.5),
prior.sigma = c(1.5, 0.5))$param.inla)[c("M0", "M1", "M2")]
# random weights for the basis functions
n_s <- nrow(spde$M0)
nodemean <- rep(0, n_s)
input_data <- list(Apixel = A.pp,
spde = spde,
y = y.pp,
A = e.pp,
nu = nu,
gal = gal,
priormean_intercept = 0,
priorsd_intercept = sqrt(1000),
priormean_beta = rep(0, ncol(gal)),
priorsd_beta = rep(sqrt(1000), ncol(gal)),
priormean_R = c(6.56, 6.8),
priorsd_R = c(0.25, 0.2),
prior_rho_min = 400,
prior_rho_prob = 0.5,
prior_sigma_max = 1.5,
prior_sigma_prob = 0.5)
parameters <- list(intercept = -11,
beta = c(2, 6),
log_R = c(6.56, 6.8),
log_a = c(0,0),
log_sigma = log(1.5),
log_rho = log(400),
nodemean = nodemean)
obj <- MakeADFun(
data = input_data,
parameters = parameters,
random = c('nodemean', 'intercept', 'beta', 'log_R', 'log_a'),
silent = TRUE,
DLL = "LGCP_cov_spde")
# non-marked point process
tm <- Sys.time()
cat("Doing AGHQ, time = ",format(tm),"\n")
LGCP_fit_no_marks <- aghq::marginal_laplace_tmb(
obj,
3,
startingvalue = c(parameters$log_sigma, parameters$log_rho)
)
aghqtime <- difftime(Sys.time(),tm,units = 'secs')
#saveRDS(LGCP_fit_no_marks,file = "LGCP_v11_cov_spde_marks/LGCP_v11_non_marked.RDS")
cat("AGHQ took: ",format(aghqtime),"\n")
library(TMB)
precompile()
library(geostatsp)
library(aghq)
library(tmbstan)
library(tidyverse)
library(spatstat)
library(spatial)
library(sp)
library(sf)
library(maptools)
library(raster)
library(fields)
library(viridis)
library(rstan)
library(INLA)
library(adehabitatMA)
library(rgeos)
library(plotly)
library(inlabru)
library(excursions)
# Compile TMB template-- only need to do once
compile('src/LGCP_cov_spde.cpp')
library(TMB)
precompile()
library(geostatsp)
library(aghq)
library(tmbstan)
library(tidyverse)
library(spatstat)
library(spatial)
library(sp)
library(sf)
library(maptools)
library(raster)
library(fields)
library(viridis)
library(rstan)
library(INLA)
library(adehabitatMA)
library(rgeos)
library(plotly)
library(inlabru)
library(excursions)
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '$> log.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '&> logfile.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '&> logfile.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '&> logfile.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '&> logfile.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
source('src/inla_mesh_dual.R')
dyn.load(dynlib(file.path("src/LGCP_color_hetero_var")))
# ================================================================ Data pre-processing and Preparation ======================================================================= #
v_acs <- read_csv('data/v11acs_GC.csv')
GC_color <- v_acs$color
library(TMB)
precompile()
library(geostatsp)
library(aghq)
library(tmbstan)
library(tidyverse)
library(spatstat)
library(spatial)
library(sp)
library(sf)
library(maptools)
library(raster)
library(fields)
library(viridis)
library(rstan)
library(INLA)
library(adehabitatMA)
library(rgeos)
library(plotly)
library(inlabru)
library(excursions)
# Compile TMB template-- only need to do once
#compile('src/LGCP_color_hetero_var.cpp')
source('src/inla_mesh_dual.R')
dyn.load(dynlib(file.path("src/LGCP_color_hetero_var")))
# ================================================================ Data pre-processing and Preparation ======================================================================= #
v_acs <- read_csv('data/v11acs_GC.csv')
GC_color <- v_acs$color
X <- c(1, 4095, 4214, 219)
Y <- c(1, 100.5, 4300, 4044)
region <- Polygon(cbind(X,Y))
region <- SpatialPolygons(list(Polygons(list(region),'region')))
region <- SpatialPolygonsDataFrame(region, data.frame(id = region@polygons[[1]]@ID, row.names = region@polygons[[1]]@ID))
plot(region)
points(v_acs[,3:4])
spv <- SpatialPoints(v_acs[,3:4])
# construct spde mesh
v_mesh <- inla.mesh.2d(loc = spv, boundary = region,
max.edge = c(80, 800), cutoff = 40, max.n.strict = 1300L)
# dual mesh for the spde mesh nodes to get the exposure weights
dmesh <- inla.mesh.dual(v_mesh)
nv <- v_mesh$n
domain.polys <- Polygons(list(Polygon(cbind(X,Y))), '0')
domainSP <- SpatialPolygons(list(domain.polys))
# exposure weights
w <- sapply(1:length(dmesh), function(i) {
if (gIntersects(dmesh[i, ], domainSP))
return(gArea(gIntersection(dmesh[i, ], domainSP)))
else return(0)
})
# response vector
y.pp <- rep(0:1, c(nv, nrow(spv@coords)))
# exposure vector
e.pp <- c(w, rep(0, nrow(spv@coords)))
# mesh nodes locations
loc_mesh <- v_mesh$loc[,1:2]
colnames(loc_mesh) <- c('x','y')
imat <- inla.spde.make.A(v_mesh, loc = v_mesh$loc[,1:2])
lmat <- inla.spde.make.A(v_mesh, loc = spv)
# projection matrix for the mesh nodes and the point locations
A.pp <- rbind(imat, lmat)
loc <- rbind(loc_mesh, v_acs[,3:4])
# covariate values at the locations
gal1 <- (loc$x*cos(pi/18) - loc$y*sin(pi/18) - 800)^2 + (loc$x*sin(pi/18) + loc$y*cos(pi/18)-1950)^2/1.733522
gal2 <- ((loc$x-2300)*cos(pi/6)- (loc$y-5800)*sin(pi/6))^2 + ((loc$x-2300)*sin(pi/6) + (loc$y-5800)*cos(pi/6))^2/2.25
gal <- cbind(gal1, gal2)
# spde stuff
nu <- 1
# spde model
spde <- (inla.spde2.pcmatern(mesh = v_mesh, alpha = 2,
prior.range = c(400, 0.5),
prior.sigma = c(1.5, 0.5))$param.inla)[c("M0", "M1", "M2")]
# random weights for the basis functions
n_s <- nrow(spde$M0)
nodemean <- rep(0, n_s)
View(lmat)
A.m <- lmat
nodemean_m <- nodemean
A.m %*% nodemean_m
input_data <- list(Apixel = A.pp,
Apixel_m = A.m,
spde = spde,
y = y.pp,
A = e.pp,
marks = GC_color,
nu = nu,
gal = gal,
priormean_intercept = 0,
priorsd_intercept = sqrt(1000),
priormean_beta = rep(0, ncol(gal)),
priorsd_beta = rep(sqrt(1000), ncol(gal)),
priormean_R = c(6.56, 6.8),
priorsd_R = c(0.25, 0.2),
priormean_intercept_m = 0,
priorsd_intercept_m = sqrt(1000),
priormean_intercept_v = 0,
priorsd_intercept_v = sqrt(1000),
priormean_beta_v = rep(0, ncol(gal)),
priorsd_beta_v = rep(sqrt(1000), ncol(gal)),
priormean_R_v = c(6.56, 6.8),
priorsd_R_v = c(0.25, 0.2),
priormean_alpha = 1,
priorsd_alpha = sqrt(10),
prior_rho_min = 400,
prior_rho_prob = 0.5,
prior_sigma_max = 1.5,
prior_sigma_prob = 0.5,
prior_rho_min_m = 1000,
prior_rho_prob_m = 0.5,
prior_sigma_max_m = 1.5,
prior_sigma_prob_m = 0.5)
parameters <- list(intercept = -11,
beta = c(2,6),
log_R = c(6.56,6.8),
log_a = c(0,0),
intercept_m = -1.5,
intercept_v = -0.15,
beta_v = c(2,6),
log_R_v = c(6.56, 6.8),
log_a_v = c(0,0),
alpha = 1,
log_sigma = log(1.5),
log_rho = log(400),
log_sigma_m = log(1.5),
log_rho_m = log(1000),
nodemean = nodemean,
nodemean_m = nodemean_m)
obj <- MakeADFun(
data = input_data,
parameters = parameters,
random = c('nodemean','nodemean_m', 'intercept', 'beta', 'log_R', 'log_a','intercept_v',
'intercept_m', 'beta_m', 'log_R_m', 'log_a_m'),
silent = TRUE,
DLL = "LGCP_color_hetero_var")
obj <- MakeADFun(
data = input_data,
parameters = parameters,
random = c('nodemean','nodemean_m', 'intercept', 'beta', 'log_R', 'log_a','intercept_m',
'intercept_v', 'beta_v', 'log_R_v', 'log_a_v'),
silent = TRUE,
DLL = "LGCP_color_hetero_var")
LGCP_fit_weight <- aghq::marginal_laplace_tmb(
obj,
3,
startingvalue = c(parameters$alpha, parameters$log_sigma, parameters$log_rho, parameters$log_sigma_m, parameters$log_rho_m)
)
library(TMB)
precompile()
library(geostatsp)
library(aghq)
library(tmbstan)
library(tidyverse)
library(spatstat)
library(spatial)
library(sp)
library(sf)
library(maptools)
library(raster)
library(fields)
library(viridis)
library(rstan)
library(INLA)
library(adehabitatMA)
library(rgeos)
library(plotly)
library(inlabru)
library(excursions)
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '&> logfile.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '&> logfile.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '&> logfile.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp', '&> logfile.log')
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
library(TMB)
precompile()
library(geostatsp)
library(aghq)
library(tmbstan)
library(tidyverse)
library(spatstat)
library(spatial)
library(sp)
library(sf)
library(maptools)
library(raster)
library(fields)
library(viridis)
library(rstan)
library(INLA)
library(adehabitatMA)
library(rgeos)
library(plotly)
library(inlabru)
library(excursions)
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
library(TMB)
precompile()
library(geostatsp)
library(aghq)
library(tmbstan)
library(tidyverse)
library(spatstat)
library(spatial)
library(sp)
library(sf)
library(maptools)
library(raster)
library(fields)
library(viridis)
library(rstan)
library(INLA)
library(adehabitatMA)
library(rgeos)
library(plotly)
library(inlabru)
library(excursions)
# Compile TMB template-- only need to do once
#compile('src/LGCP_color_hetero_var.cpp')
source('src/inla_mesh_dual.R')
dyn.load(dynlib(file.path("src/LGCP_color_hetero_var")))
v_acs <- read_csv('data/v11acs_GC.csv')
GC_color <- v_acs$color
X <- c(1, 4095, 4214, 219)
Y <- c(1, 100.5, 4300, 4044)
region <- Polygon(cbind(X,Y))
region <- SpatialPolygons(list(Polygons(list(region),'region')))
region <- SpatialPolygonsDataFrame(region, data.frame(id = region@polygons[[1]]@ID, row.names = region@polygons[[1]]@ID))
plot(region)
points(v_acs[,3:4])
spv <- SpatialPoints(v_acs[,3:4])
# construct spde mesh
v_mesh <- inla.mesh.2d(loc = spv, boundary = region,
max.edge = c(80, 800), cutoff = 40, max.n.strict = 1300L)
# dual mesh for the spde mesh nodes to get the exposure weights
dmesh <- inla.mesh.dual(v_mesh)
nv <- v_mesh$n
domain.polys <- Polygons(list(Polygon(cbind(X,Y))), '0')
domainSP <- SpatialPolygons(list(domain.polys))
# exposure weights
w <- sapply(1:length(dmesh), function(i) {
if (gIntersects(dmesh[i, ], domainSP))
return(gArea(gIntersection(dmesh[i, ], domainSP)))
else return(0)
})
# response vector
y.pp <- rep(0:1, c(nv, nrow(spv@coords)))
# exposure vector
e.pp <- c(w, rep(0, nrow(spv@coords)))
# mesh nodes locations
loc_mesh <- v_mesh$loc[,1:2]
colnames(loc_mesh) <- c('x','y')
imat <- inla.spde.make.A(v_mesh, loc = v_mesh$loc[,1:2])
lmat <- inla.spde.make.A(v_mesh, loc = spv)
# projection matrix for the mesh nodes and the point locations
A.pp <- rbind(imat, lmat)
A.m <- lmat
loc <- rbind(loc_mesh, v_acs[,3:4])
# covariate values at the locations
gal1 <- (loc$x*cos(pi/18) - loc$y*sin(pi/18) - 800)^2 + (loc$x*sin(pi/18) + loc$y*cos(pi/18)-1950)^2/1.733522
gal2 <- ((loc$x-2300)*cos(pi/6)- (loc$y-5800)*sin(pi/6))^2 + ((loc$x-2300)*sin(pi/6) + (loc$y-5800)*cos(pi/6))^2/2.25
gal <- cbind(gal1, gal2)
# spde stuff
nu <- 1
# spde model
spde <- (inla.spde2.pcmatern(mesh = v_mesh, alpha = 2,
prior.range = c(400, 0.5),
prior.sigma = c(1.5, 0.5))$param.inla)[c("M0", "M1", "M2")]
# random weights for the basis functions
n_s <- nrow(spde$M0)
nodemean <- rep(0, n_s)
nodemean_m <- nodemean
# ============================================================== Non-marked point process model =============================================================== #
# # input data for the non-marked point process
input_data <- list(Apixel = A.pp,
Apixel_m = A.m,
spde = spde,
y = y.pp,
A = e.pp,
marks = GC_color,
nu = nu,
gal = gal,
priormean_intercept = 0,
priorsd_intercept = sqrt(1000),
priormean_beta = rep(0, ncol(gal)),
priorsd_beta = rep(sqrt(1000), ncol(gal)),
priormean_R = c(6.56, 6.8),
priorsd_R = c(0.25, 0.2),
priormean_intercept_m = 0,
priorsd_intercept_m = sqrt(1000),
priormean_intercept_v = 0,
priorsd_intercept_v = sqrt(1000),
priormean_beta_v = rep(0, ncol(gal)),
priorsd_beta_v = rep(sqrt(1000), ncol(gal)),
priormean_R_v = c(6.56, 6.8),
priorsd_R_v = c(0.25, 0.2),
priormean_alpha = 1,
priorsd_alpha = sqrt(10),
prior_rho_min = 400,
prior_rho_prob = 0.5,
prior_sigma_max = 1.5,
prior_sigma_prob = 0.5,
prior_rho_min_m = 1000,
prior_rho_prob_m = 0.5,
prior_sigma_max_m = 1.5,
prior_sigma_prob_m = 0.5)
parameters <- list(intercept = -11,
beta = c(2,6),
log_R = c(6.56,6.8),
log_a = c(0,0),
intercept_m = -1.5,
intercept_v = -0.15,
beta_v = c(2,6),
log_R_v = c(6.56, 6.8),
log_a_v = c(0,0),
alpha = 1,
log_sigma = log(1.5),
log_rho = log(400),
log_sigma_m = log(1.5),
log_rho_m = log(1000),
nodemean = nodemean,
nodemean_m = nodemean_m)
obj <- MakeADFun(
data = input_data,
parameters = parameters,
random = c('nodemean','nodemean_m', 'intercept', 'beta', 'log_R', 'log_a','intercept_m',
'intercept_v', 'beta_v', 'log_R_v', 'log_a_v'),
silent = TRUE,
DLL = "LGCP_color_hetero_var")
LGCP_fit_weight <- aghq::marginal_laplace_tmb(
obj,
3,
startingvalue = c(parameters$alpha, parameters$log_sigma, parameters$log_rho, parameters$log_sigma_m, parameters$log_rho_m)
)
library(TMB)
precompile()
library(geostatsp)
library(aghq)
library(tmbstan)
library(tidyverse)
library(spatstat)
library(spatial)
library(sp)
library(sf)
library(maptools)
library(raster)
library(fields)
library(viridis)
library(rstan)
library(INLA)
library(adehabitatMA)
library(rgeos)
library(plotly)
library(inlabru)
library(excursions)
# Compile TMB template-- only need to do once
compile('src/LGCP_color_hetero_var.cpp')
